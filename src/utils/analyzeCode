// utils/codeAnalyzer.js

export const analyzeCodeStructure = (content, language) => {
  const info = {
    imports: [],
    component: null,
    exports: [],
    contextUsage: [], // Cosa usa questo file dai context?
    hooks: [],
  };

  // 1. Analisi Imports (External vs Local)
  const importRegex = /import\s+(?:({[^}]+})|(\w+))\s+from\s+['"]([^'"]+)['"]/g;
  let match;
  while ((match = importRegex.exec(content)) !== null) {
    const isLocal = match[3].startsWith(".");
    const items = match[1]
      ? match[1]
          .replace(/[{}]/g, "")
          .split(",")
          .map((s) => s.trim())
      : [match[2]];

    info.imports.push({
      source: match[3],
      items,
      type: isLocal ? "local" : "external",
    });
  }

  // 2. Analisi Componente e Props (React)
  // Cerca: function Nome({ prop1, prop2 }) o const Nome = ({ prop1, prop2 }) =>
  const funcCompRegex = /function\s+(\w+)\s*\(\s*{([^}]*)}\s*\)/;
  const arrowCompRegex = /const\s+(\w+)\s*=\s*\(\s*{([^}]*)}\s*\)\s*=>/;

  const compMatch =
    content.match(funcCompRegex) || content.match(arrowCompRegex);
  if (compMatch) {
    info.component = {
      name: compMatch[1],
      props: compMatch[2]
        .split(",")
        .map((p) => p.trim().split("=")[0].trim())
        .filter(Boolean),
    };
  }

  // 3. Analisi Context Usage (CRUCIALE per il tuo problema)
  // Cerca: const { addLink, groups } = useDashboard()
  const contextRegex = /const\s+{([^}]+)}\s*=\s*(use\w+)\(/g;
  while ((match = contextRegex.exec(content)) !== null) {
    const vars = match[1].split(",").map((s) => s.trim());
    const hookName = match[2];
    info.contextUsage.push({ hook: hookName, vars });
  }

  // 4. Analisi Exports (Cosa offre questo file agli altri?)
  // Cerca: export const nome = ... o export function nome(...)
  const exportRegex = /export\s+(?:const|function)\s+(\w+)/g;
  while ((match = exportRegex.exec(content)) !== null) {
    info.exports.push(match[1]);
  }

  // Cerca: export default
  if (content.match(/export\s+default\s+(\w+)/)) {
    info.exports.push("default export");
  }

  // Cerca specificamente valori di Provider (es. <Context.Provider value={{ a, b }}>)
  // Questo aiuta l'LLM a sapere cosa c'Ã¨ nel context
  const providerValueRegex = /value\s*=\s*{\s*{([^}]+)}\s*}/;
  const providerMatch = content.match(providerValueRegex);
  if (providerMatch) {
    info.providerValues = providerMatch[1].split(",").map((s) => s.trim());
  }

  return info;
};

export const formatStructureSummary = (structure, filePath) => {
  const lines = [];

  if (structure.imports.length) {
    lines.push(
      `- imports: ${structure.imports.slice(0, 3).join(", ")}${structure.imports.length > 3 ? ` +${structure.imports.length - 3} more` : ""}`
    );
  }

  if (structure.state.length) {
    lines.push(`- state: ${structure.state.join(", ")}`);
  }

  if (structure.functions.length) {
    lines.push(
      `- functions: ${structure.functions.slice(0, 5).join(", ")}${structure.functions.length > 5 ? "..." : ""}`
    );
  }

  if (structure.exports.length) {
    lines.push(`- exports: ${structure.exports.join(", ")}`);
  }

  return lines.join("\n");
};
